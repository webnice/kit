/*

Генератор кода встраиваемых ресурсов.
Аргументы:
	--package - Название пакета для генерации .go файлов.
	--path    - Путь создания .go файлов с ресурсами. Если пусто, файлы создаются в текущей папке.

Так же ожидаются переменные окружения:
EMBEDDER_STATIC_BASE_DIR  - Корневая директория статических ресурсов.
EMBEDDER_STATIC_RESOURCES - Группы ресурсов и папками самих ресурсов.
                            Формат: group_name1:path/to/folder1,group_name2:path/to/folder2

Создаются .go файлы по шаблону имени файла:
	resource_content_{{ groupName }}_{{ resourceNumber }}.go
Где:
	groupName      - строка приведённая к нижнему регистру не содержащая пробелы.
	resourceNumber - порядковый номер ресурса в формате %020d.

Пример: resource_content_test_group_00000000000000000001.go

*/

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"log"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
	"time"

	"github.com/webnice/dic"
)

const tpl = `// НЕ РЕДАКТИРОВАТЬ! Изменения будут перезаписаны при следующей генерации.
// Code generated by go generate; DO NOT EDIT.

package {{ .package }}

import (
	"time"

	kitModelResource "github.com/webnice/kit/v4/model/resource"
)

func init() {
	_ = Get().Add(
		"{{ .group }}",
		"{{ .info.Name }}",
		kitModelResource.Resource{
			Size: {{ .info.Size }},
			Time: func() time.Time {
				t, _ := time.ParseInLocation(time.RFC3339Nano, "{{ .info.Time.Format .info.TimeFormat }}", time.Local)
				return t
			}(),
			ContentType: "{{ .info.ContentType }}",
			Content: []byte{
				{{ .info.Content }},
			},
		})
}
`

var (
	templateEmbed      = template.Must(template.New("").Parse(tpl))
	rexResourcePattern = regexp.MustCompile(`(?mi)^resource_content_.*_\d{20}\.go`)
)

type (
	configuration struct {
		Package string                   // Название пакета.
		Path    string                   // Директория размещения создаваемых файлов.
		WorkDir string                   // Текущая рабочая директория.
		BaseDir string                   // Корневая директория статических ресурсов.
		Sources map[string]resourceGroup // Встраиваемые ресурсы.
	}
	resourceGroup struct {
		Path string         // Базовая директория группы ресурсов.
		File []resourceInfo // Файлы ресурсов с информацией о ресурсах.
	}
	resourceInfo struct {
		Size        uint64           // Размер ресурса в байтах.
		Time        time.Time        // Дата и время создания ресурса.
		TimeFormat  string           // Формат времени. По умолчанию time.RFC3339Nano.
		Name        string           // Название ресурса. Путь и имя файла относительно базовой директории.
		ContentType string           // Определённый по расширению имени файла тип контента ресурса.
		Content     *strings.Builder // Преобразованный под шаблонизатор, контент файла.
	}
)

func main() {
	var (
		cfg *configuration
		err error
	)

	// Получение аргументов.
	if cfg, err = getArg(); err != nil {
		log.Fatalf("Ошибка загрузки исходных параметров: %s.", err)
	}
	// Получение списка ресурсов.
	if err = getResourceList(cfg); err != nil {
		log.Fatalf("Ошибка получения списка ресурсов: %s.", err)
	}
	// Удаление старых ресурсов.
	if err = cleanResourceContent(cfg); err != nil {
		log.Fatalf("Ошибка удаления старых ресурсов: %s.", err)
		return
	}
	// Создание новых ресурсов.
	if err = makeResourceContent(cfg); err != nil {
		log.Fatalf("Ошибка создания ресурсов: %s.", err)
		return
	}
}

// Загрузка конфигурации из аргументов командной строки и переменных окружения.
func getArg() (cfg *configuration, err error) {
	const envEmbedderStaticBaseDir, envEmbedderStaticResources = `EMBEDDER_STATIC_BASE_DIR`, `EMBEDDER_STATIC_RESOURCES`
	var (
		abs      func(string, string) string
		source   string
		src, tmp []string
		n        int
	)

	abs = func(wd, p string) string {
		if len(p) == 0 || len(p) > 0 && p[0] != '/' {
			p = path.Join(wd, p)
		}
		return p
	}
	cfg = &configuration{Sources: make(map[string]resourceGroup)}
	flag.StringVar(&cfg.Package, "package", "", "Название пакета для генерации кода в пакете.")
	flag.StringVar(&cfg.Path, "path", "", "Путь размещения создаваемых файлов.")
	flag.Parse()
	if cfg.WorkDir, err = os.Getwd(); err != nil {
		err = fmt.Errorf("ошибка получения текущей директории: %w", err)
		return
	}
	cfg.Path = abs(cfg.WorkDir, cfg.Path)
	cfg.BaseDir, source = os.Getenv(envEmbedderStaticBaseDir), os.Getenv(envEmbedderStaticResources)
	cfg.BaseDir, src = path.Join(abs(cfg.WorkDir, cfg.BaseDir), "."), strings.Split(source, ",")
	for n = range src {
		if tmp = strings.Split(src[n], ":"); len(tmp) != 2 {
			continue
		}
		source = strings.ToLower(tmp[0])
		tmp[1] = abs(cfg.BaseDir, tmp[1])
		cfg.Sources[source] = resourceGroup{Path: tmp[1]}
	}

	return
}

// Получение списка всех файлов ресурсов с необходимыми атрибутами.
func getResourceList(cfg *configuration) (err error) {
	var (
		group string
		info  []resourceInfo
	)

	for group = range cfg.Sources {
		if info, err = getSourceInfo(cfg.Sources[group].Path, ""); err != nil {
			return
		}
		cfg.Sources[group] = resourceGroup{
			Path: cfg.Sources[group].Path,
			File: info,
		}
	}

	return
}

// Рекурсивное получение списка ресурсов с атрибутами для одной группы ресурсов.
func getSourceInfo(base string, p string) (ret []resourceInfo, err error) {
	const limitSize = 100000000
	var (
		fid    []os.DirEntry
		fi     os.FileInfo
		inf    []resourceInfo
		n      int
		dn, fn string
		buf    []byte
		mime   dic.IMime
	)

	dn = path.Join(base, p)
	if fid, err = os.ReadDir(dn); err != nil {
		err = fmt.Errorf("чтение директории %q прервано ошибкой: %w", dn, err)
		return
	}
	for n = range fid {
		if fid[n].IsDir() {
			if inf, err = getSourceInfo(base, path.Join(p, fid[n].Name())); err != nil {
				return
			}
			ret = append(ret, inf...)
			continue
		}
		if fi, err = fid[n].Info(); err != nil {
			err = nil
			continue
		}

		if fi.Size() == 0 {
			continue
		}
		fn = path.Join(base, p, fid[n].Name())
		if buf, err = getFileContent(fn); err != nil {
			return
		}
		if mime = dic.File().MimeByFilename(fn); mime == nil {
			mime = dic.File().MimeByContent(buf)
		}
		if mime == nil {
			err = fmt.Errorf("неизвестный тип контента, расширение имени файла %q", filepath.Ext(fn))
		}
		if fi.Size() > limitSize {
			log.Printf("Файл %q пропущен, размер файла %d, больше лимита %d байт.", fn, fi.Size(), limitSize)
			continue
		}
		ret = append(ret, resourceInfo{
			Size:        uint64(fi.Size()),
			Time:        fi.ModTime(),
			TimeFormat:  time.RFC3339Nano,
			Name:        path.Join(p, fid[n].Name()),
			ContentType: mime.String(),
			Content:     getSliceOfBytesAsString(buf),
		})
	}

	return
}

// Получение типа контента по содержимому и названию файла.
//
//goland:noinspection ALL
func getFileContentType(content []byte) (ret string, err error) {
	var (
		buf []byte
		n   int
	)

	buf = make([]byte, 512)
	if n = copy(buf, content); n == 0 {
		err = fmt.Errorf("контент пустой")
	}
	ret = http.DetectContentType(buf)

	return
}

// Загрузка всего контента файла.
func getFileContent(fn string) (ret []byte, err error) {
	var fh *os.File

	if fh, err = os.Open(fn); err != nil {
		return
	}
	defer func() { _ = fh.Close() }()
	if ret, err = io.ReadAll(fh); err != nil {
		err = fmt.Errorf("чтение файла %q прервано ошибкой: %w", fn, err)
		return
	}

	return
}

// Преобразование среза байт в строку для golang со срезом байт.
func getSliceOfBytesAsString(bytes []byte) (ret *strings.Builder) {
	const delimiter, newLine, lineWidth = ", ", "\n", 16
	var (
		b byte
		n int
	)

	ret = new(strings.Builder)
	for _, b = range bytes {
		if ret.Len() > 0 {
			ret.WriteString(delimiter)
		}
		if n >= lineWidth {
			n = 0
			ret.WriteString(newLine)
		}
		ret.WriteString(fmt.Sprintf("0x%02x", int(b)))
		n++
	}

	return
}

// Удаление старых ресурсов.
func cleanResourceContent(cfg *configuration) (err error) {
	var (
		fid []fs.DirEntry
		n   int
	)

	if fid, err = os.ReadDir(cfg.Path); err != nil {
		err = fmt.Errorf("чтение директории %q прервано ошибкой: %w", cfg.Path, err)
		return
	}
	for n = range fid {
		if fid[n].IsDir() {
			continue
		}
		if !rexResourcePattern.MatchString(fid[n].Name()) {
			continue
		}
		if err = os.Remove(path.Join(cfg.Path, fid[n].Name())); err != nil {
			err = fmt.Errorf("удаление старого файла ресурса %q прервано ошибкой: %w", fid[n].Name(), err)
			return
		}
	}

	return
}

// Создание новых ресурсов.
func makeResourceContent(cfg *configuration) (err error) {
	var (
		buf       *bytes.Buffer
		data      []byte
		groupName string
		n         int
		info      resourceInfo
		vars      map[string]interface{}
	)

	for groupName = range cfg.Sources {
		for n = range cfg.Sources[groupName].File {
			info = cfg.Sources[groupName].File[n]
			vars = make(map[string]interface{})
			vars["package"] = cfg.Package
			vars["group"] = groupName
			vars["info"] = info
			buf = &bytes.Buffer{}
			if err = templateEmbed.Execute(buf, vars); err != nil {
				err = fmt.Errorf("обработка шаблона прервана ошибкой: %w", err)
				return
			}
			if data, err = format.Source(buf.Bytes()); err != nil {
				err = fmt.Errorf("форматирование созданного .go файла прервана ошибкой: %w", err)
				return
			}
			if err = saveFile(cfg.Path, groupName, uint64(n+1), data); err != nil {
				return
			}
			log.Printf("+Создан ресурс: %s:%s, размер: %d байт.", groupName, info.Name, info.Size)
			info.Content.Reset()
			info.Content = nil
		}
	}

	return
}

// Сохранение созданного файла с ресурсом.
func saveFile(dir string, group string, number uint64, data []byte) (err error) {
	const (
		defaultFileMode = os.FileMode(0644)
		fnTemplate      = `resource_content_%s_%020d.go`
	)
	var fn string

	fn = fmt.Sprintf(fnTemplate, group, number)
	fn = path.Join(dir, fn)
	if err = os.WriteFile(fn, data, defaultFileMode); err != nil {
		err = fmt.Errorf("создание файла %q прервано ошибкой: %w", fn, err)
		return
	}

	return
}
