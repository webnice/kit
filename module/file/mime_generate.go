//go:build ignore
// +build ignore

// This program generates mime.go. It can be invoked by running go generate.

package main

import (
	"bufio"
	"bytes"
	"encoding/csv"
	"io/ioutil"
	"log"
	"os"
	"path"
	"regexp"
	"strings"
	"text/template"
	"time"
)

const (
	sourceMimeData        = `mime/`   // Папка с исходными файлами типов mime.
	filenameMime          = `mime.go` // Имя генерируемого файла.
	dataFormatSystem      = `types`   // Формат данных применяемый в linux и в apache.
	dataFormatNginxConfig = `cfg`     // Формат данных применяемый в nginx.
	dataFormatIanaCSV     = `csv`     // Формат данных https://www.iana.org/assignments/media-types/media-types.xhtml.
)

var (
	rexExtension    = regexp.MustCompile(`\.([^\.]+)$`)
	rexSplitter     = regexp.MustCompile(`[\s\W]`)
	rexExtensionBad = regexp.MustCompile(`[\+\[\]\-]`)
)

var packageTemplate = template.Must(template.New("").
	Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated using data from "{{ .Folder }}" folder

package file // import "github.com/webnice/kit/models/file"

const (
{{- range .Types }}
	{{ printf "%s = %q" .Name .Type }}
{{- end }}
)

var mimeTypeExtension = map[string]string{
{{- range .Types }}
	{{ printf "%s: %q" .Name .Extension }},
{{- end }}
}
`))

// MimeTypeItem Одна запись mime type.
type MimeTypeItem struct {
	Type      string // Mime-Type.
	Extension string // File extension.
	Src       string // Data format source.
	Name      string // Constant name.
}

func main() { os.Exit(Main()) }

// Main Program entry point with exit code and log flushing waiting.
func Main() (ret int) {
	const errUnknownFormat = "unknown format %q, skipped"
	var (
		err            error
		buf            *bytes.Buffer
		dirContent     []os.FileInfo
		mimeTypes, tmp []*MimeTypeItem
		deduplicate    map[string]*MimeTypeItem
		fh             *os.File
		ext, filename  string
		i              int
		ok             bool
	)

	dirContent, err = ioutil.ReadDir(sourceMimeData)
	die(err)
	for i = range dirContent {
		if dirContent[i].IsDir() {
			continue
		}
		filename = path.Join(sourceMimeData, dirContent[i].Name())
		buf, ext, err = ReadFileBody(filename)
		switch die(err); ext {
		case dataFormatSystem:
			tmp, err = ParseDataFormatSystem(buf)
		case dataFormatNginxConfig:
			tmp, err = ParserDataFormatNginxConfig(buf)
		case dataFormatIanaCSV:
			tmp, err = ParseDataFormatIanaCSV(buf)
		default:
			log.Printf(errUnknownFormat, ext)
			continue
		}
		if die(err); len(tmp) > 0 {
			mimeTypes = append(mimeTypes, tmp...)
			tmp = tmp[:0]
		}
	}
	deduplicate = make(map[string]*MimeTypeItem)
	for i = range mimeTypes {
		if _, ok = deduplicate[mimeTypes[i].Type]; ok {
			switch deduplicate[mimeTypes[i].Type].Src {
			case dataFormatSystem:
				deduplicate[mimeTypes[i].Type] = mimeTypes[i]
			case dataFormatIanaCSV:
				if mimeTypes[i].Src == dataFormatNginxConfig || mimeTypes[i].Src == dataFormatIanaCSV {
					deduplicate[mimeTypes[i].Type] = mimeTypes[i]
				}
			}
			continue
		}
		deduplicate[mimeTypes[i].Type] = mimeTypes[i]
	}
	// Создание имён констант.
	CreateConstantName(deduplicate)
	// Генерация файла.
	fh, err = os.Create(filenameMime)
	die(err)
	defer func() { _ = fh.Close() }()
	_ = packageTemplate.Execute(fh, struct {
		Timestamp time.Time
		Folder    string
		Types     map[string]*MimeTypeItem
	}{
		Timestamp: time.Now().In(time.UTC),
		Folder:    sourceMimeData,
		Types:     deduplicate,
	})

	return
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

// CreateConstantName Создание имён констант
func CreateConstantName(data map[string]*MimeTypeItem) {
	const prefix, delimiter = `mime`, ``
	var (
		tn  string
		tmp []string
		bts string
		i   int
	)

	for tn = range data {
		tmp = rexSplitter.Split(tn, -1)
		for i = range tmp {
			bts = tmp[i]
			if len(bts) > 0 {
				bts = strings.ToUpper(string(bts[0])) + string(bts[1:])
			}
			tmp[i] = bts
		}
		data[tn].Name = prefix + strings.Join(tmp, delimiter)
	}
}

// ReadFileBody Чтение содержимого файла.
func ReadFileBody(filename string) (ret *bytes.Buffer, ext string, err error) {
	var (
		buf []byte
		str []string
	)

	if buf, err = ioutil.ReadFile(filename); err != nil {
		return
	}
	ret = bytes.NewBuffer(buf)
	if str = rexExtension.FindStringSubmatch(filename); len(str) >= 2 {
		ext = strings.ToLower(str[1])
	}

	return
}

// ParserDataFormatNginxConfig Разбор формата файла nginx configuration.
func ParserDataFormatNginxConfig(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	const (
		byteBegin     = '{'
		byteEnd       = '}'
		byteReturn    = '\r'
		byteNewLine   = '\n'
		byteDelimiter = ';'
	)
	var (
		bbf  *bytes.Buffer
		rdr  *bufio.Reader
		buf  []byte
		line string
		tmp  []*MimeTypeItem
	)

	rdr = bufio.NewReader(data)
	if _, err = rdr.ReadBytes(byteBegin); err != nil {
		return
	}
	if buf, err = rdr.ReadBytes(byteEnd); err != nil {
		return
	}
	if len(buf) > 0 {
		buf = buf[:len(buf)-1]
	}
	buf = bytes.Replace(buf, []byte{byteReturn}, []byte(""), -1)
	buf = bytes.Replace(buf, []byte{byteNewLine}, []byte(""), -1)
	bbf = bytes.NewBuffer(buf)
	rdr = bufio.NewReader(bbf)
	for {
		line, err = rdr.ReadString(byteDelimiter)
		line = strings.TrimSpace(strings.TrimRight(line, string(byteDelimiter)))
		if len(line) != 0 {
			if tmp = ParserDataFormatNginxConfigItem(line); len(tmp) > 0 {
				ret = append(ret, tmp...)
			}
		}
		if err != nil {
			err = nil
			break
		}
	}

	return
}

// ParserDataFormatNginxConfigItem Обработка одной записи в формате nginx.
func ParserDataFormatNginxConfigItem(line string) (ret []*MimeTypeItem) {
	var (
		tmp []string
		ext []string
		i   int
	)

	tmp = strings.SplitAfterN(line, " ", 2)
	if len(tmp) < 2 {
		return
	}
	if tmp[0] = strings.TrimSpace(tmp[0]); len(tmp[0]) == 0 {
		return
	}
	ext = strings.Split(tmp[1], " ")
	for i = range ext {
		if ext[i] = strings.TrimSpace(ext[i]); len(ext[i]) == 0 {
			continue
		}
		if rexExtensionBad.MatchString(ext[i]) {
			continue
		}
		ret = append(ret, &MimeTypeItem{
			Type:      strings.ToLower(tmp[0]),
			Extension: strings.ToLower(ext[i]),
			Src:       dataFormatNginxConfig,
		})
	}

	return
}

// ParseDataFormatSystem Разбор формата файла linux и apache.
func ParseDataFormatSystem(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	const byteComment = '#'
	var (
		scn                 *bufio.Scanner
		tmp                 []string
		mimeType, extension string
	)

	scn = bufio.NewScanner(data)
	for scn.Scan() {
		tmp = strings.Fields(scn.Text())
		if len(tmp) <= 1 || tmp[0][0] == byteComment {
			continue
		}
		mimeType = tmp[0]
		for _, extension = range tmp[1:] {
			if extension[0] == byteComment {
				break
			}
			if rexExtensionBad.MatchString(extension) {
				continue
			}
			ret = append(ret, &MimeTypeItem{
				Type:      strings.ToLower(mimeType),
				Extension: strings.ToLower(extension),
				Src:       dataFormatSystem,
			})
		}
	}

	return
}

// ParseDataFormatIanaCSV Разбор формата файла https://www.iana.org/assignments/media-types/media-types.xhtml.
func ParseDataFormatIanaCSV(data *bytes.Buffer) (ret []*MimeTypeItem, err error) {
	var (
		rdr     *csv.Reader
		tmp     []*MimeTypeItem
		record  []string
		numLine uint64
	)

	rdr = csv.NewReader(data)
	for {
		numLine++
		record, err = rdr.Read()
		if numLine == 1 {
			continue
		}
		if len(record) >= 3 {
			if tmp = ParseDataFormatIanaCSVItem(record); len(tmp) > 0 {
				ret = append(ret, tmp...)
			}
		}
		if err != nil {
			err = nil
			break
		}
	}

	return
}

// ParseDataFormatIanaCSVItem Разбор строки CSV файла.
func ParseDataFormatIanaCSVItem(record []string) (ret []*MimeTypeItem) {
	var (
		mimeType  string
		extension string
	)

	if mimeType = strings.TrimSpace(record[1]); len(mimeType) == 0 {
		return
	}
	extension = strings.TrimSpace(record[0])
	if rexExtensionBad.MatchString(extension) {
		return
	}
	ret = append(ret, &MimeTypeItem{
		Type:      strings.ToLower(mimeType),
		Extension: strings.ToLower(extension),
		Src:       dataFormatIanaCSV,
	})

	return
}
